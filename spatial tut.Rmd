---
title: "A brief intro to handling and mapping spatial data in R"
author: "Ben Wagner"
date: "5/6/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(raster)
library(viridis)
library(tidyverse)
```

# Working with spatial data in `R`

Many of you will be familiar with using spatial data such as vector data in form of shapefiles or raster data in GIS software, which can handle these files intuitively. Nevertheless, GIS do have some disadvantages when it comes to either large data sets or automation processes. `R` offers a full integration of spatial tools and references such as **GDAL** or **PROJ** and some great packages to deal with this data seamlessly. Today we are going to learn how to use the package `sf` and have a brief detour towards raster data in `R`. You are going to need to install the following packages for this tutorial:

```{r, eval=F}
install.packages(c('tidyverse', 'sf', 'raster', 'viridis'))
```

And then call the packages:

```{r, eval=F}
library(sf)
library(raster)
library(viridis)
library(tidyverse)
```

We will be working on a dataset of koala observations, that you can download [here](https://www.dropbox.com/s/1zhru8ui3btmg0n/koala.csv?dl=1), as well as a basic administrative Areas shapefile of Australia, which you can find [here](https://www.dropbox.com/s/7edsxu5eezrzrqu/Australia.rar?dl=1). For the last part we will be looking at rasters, with a digital elevation model (DEM) file as example. You can find it for download [here](https://www.dropbox.com/s/u2j6a73t7nv0lww/DEM.tif?dl=0). Please make sure these are stored within a `data/` folder in an `R` project (or working directory).

## Transforming a dataset into an `sf` object

Let's first load in our dataset and have a look at it's structure

```{r}
koala <- read.csv('data/koala.csv')

head(koala) # see the first few rows in the console
```

As we can see it contains lots of variables related to each of the observed koalas, such as `sex`, `weight` or in which `state` the observation was made. Additionally, whoever collected this data was so kind to also include the `X` and `Y` coordinates, where the observation was made. This we can use to transform this into an `sf` (simple feature) object.

```{r}
koala_sf <- st_as_sf(koala, 
                     coords = c("X", 
                                "Y"), 
                     crs = 4326)
str(koala_sf)

```

The `sf` object is a `data.frame` with a *geometry list-column*. It supports different format and spatial references. The file as it exists in your `R` environment is what you would call the *Attribute table* in a GIS software. In `R` you can use and manipulate it as any other `data.frame`. When converting a table into a `sf` we need to indicate the columns containing coordinates using `coords = c()` and we can decide on a coordinate reference system using `crs=`. Here we decide to use WGS84 (CRS = 4326), a standard Mercator coordinate frame for the Earth given in Latitude and Longitude. We can plot our now spatial data with the standard base R command:

```{r}
plot(koala_sf)

```

This will try to plot all columns (because they are now all spatially referenced). To only plot the geometries, you can:

```{r}
plot(koala_sf$geometry)

```

So far so good, but we will need a bit more data to make a nice map!

## Loading shapefiles into `R`, transforming and plotting

You can load any vector file, such as .shp or .gpkg using `st_read`. Let's get our Australia map into the environment and check it out:

```{r}
states <- st_read("data/Australia/Australia_proj.shp")

plot(states$geometry)

```

Great, we even have states column, which will we will use a bit later. To plot, simply use base `R` syntax of plotting and then plotting another graph on top using `add = T`. Instead of calling `plot(file$geometry)`, we can also call `st_geometry()`

```{r}
plot(st_geometry(states), 
     axes = TRUE)

plot(st_geometry(koala_sf), # why does this not work?
     col = "blue", 
     add = T)

```

Hm, our states are plotting fine, but where are our koala locations? Maybe we should check the coordinate reference system to see if they match... Here's how that's done:

```{r}
st_crs(states)

st_crs(koala_sf)
```

Damn, they do not match. Our Australia shapefile has a different (weird) projection. If you feel it's tedious to check the CRS in the console, simply type 

```{r}
st_crs(states)==st_crs(koala_sf)
```

`FALSE` is returned, so they don't match. We need to transform one of them to be able to plot our spatial points on top of the Australia map. `sf` has a simple solution for this using `st_transform()`. Let's do that and plot straight away.

```{r}
koala_proj <- st_transform(koala_sf, crs = st_crs(states))

plot(st_geometry(states), 
     axes = TRUE)

plot(st_geometry(koala_proj), 
     col = "blue", 
     add = T)
```

Excellent! In `st_transform` we can call any `crs` from another spatial file in the environment, our define our own using a `proj4string`. If we look at our plot, we can see that the coordinates on the axis look weird. We'd rather like latitude and longitude to make it look more comprehensive. That's now up to you to fix it!

### Challenge 1

**Load the Australia_proj and koala data again and plot them on top of each other in Mercator projection (CRS: 4326). Note: check the spatial reference of the maps first!**

*Extra challenge: color the koala points based on state! Check `?sf::plot` for tips*

```{r, include = F}
states_proj <- st_transform(states, crs = st_crs(koala_sf))

# or states_proj<-st_transform(states, crs = 4326)

```

```{r,echo=F }
plot(st_geometry(states_proj), 
     axes = TRUE)

plot(st_geometry(koala_sf), 
     col = koala_sf$state, 
     add = T)
```

Looks good! You can find the solutions to all challenges posed here at the end of the document. Don't peek!

Let's make our maps look even better.

## Simple geometric operations

`sf` supports any geometric operations you know from GIS software. We will just touch cropping here, but you can also merge, intersect, overlap and many more. For the purpose of mapping, `st_crop()` is most relevant. Let's say we want to create a map of all our Koala locations, we won't necessarily need to show all of Australia, knowing that Koalas are only distributed along the east coast. Let's crop the Australia shapefile by the extent of our observations:

```{r}
australia_koala_area<-st_crop(states_proj, koala_sf)

plot(st_geometry(australia_koala_area), axes = T)

plot(st_geometry(koala_sf), add = T)
```

Great. Let's say we want to save the new cropped shapefile to an `outputs/` folder in our project. For this we simply use `st_write()`:

```{r, eval=F}
st_write(australia_koala_area, 'outputs/koala_shape.gpkg')

```

You can choose different file extensions. Here we are saving a geopackage, as it results in only one file, rather than 4-6 for a .shp extension. Up to you ;) Let's make a good looking map with our data!

## Making a map using `ggplot2`

`ggplot2` supports plotting spatial data by calling `geom_sf()`, after defining your data to plot. In simple terms we can create a map of Australia by calling:

```{r}
ggplot(data = states_proj) + geom_sf()
```

which already looks a lot better than base R. But there are a lot of improvements to be made to create a publication-ready map. First we can assign colors based on columns in your data. We can also remove the standard grey ggplot background with a more map-friendly white grid using `theme_minimal()`

```{r}
ggplot(data = states_proj)+
  geom_sf(aes(fill = STATENAME))+
  theme_minimal()
```

We don't really need a legend here, let's remove it:

```{r}
ggplot(data = states_proj)+
  geom_sf(aes(fill = STATENAME))+
  theme_minimal()+
  guides(fill = F)
```

Using `coord_sf()` we can even change the projection while plotting in `ggplot2`, without the need of going back to reprojecting or transforming in `sf`.

```{r}
ggplot(data = states_proj)+
  geom_sf(aes(fill = STATENAME))+
  theme_minimal()+
  guides(fill = F)+
  coord_sf(crs = 3112)
```

Did you see what changed? Finally we can change the fore- and background color to make it look like proper map in a nice blue ocean:

```{r}
ggplot(data = states_proj)+
  geom_sf(size = 0.3, fill = 'white')+
  theme_minimal()+
  coord_sf(crs = 3112)+
  theme(panel.background = element_rect(fill = 'steelblue2'))
```

### Challenge 2

**Add the koala positions on top of the Australia map in ggplot2. Only plot the area that has koalas and color the points by sex of the individual. Please also give the map in Mercator projection**

*You will need to:* 

1. Add a second layer to your ggplot
2. Define the crs

```{r,echo=F }
ggplot(data = australia_koala_area)+
  geom_sf(size = 0.3, fill = 'white')+
  geom_sf(data = koala_sf, size = 2, aes(color = sex))+
  theme_minimal()+
  coord_sf(crs = 4326)+
  theme(panel.background = element_rect(fill = 'steelblue2'))

```

Good job! But unfortunately our cut-out looks like an island surrounded by seawater. If we want the map to look like a close-up of eastern Australia, we need to tell `ggplot2` to start plotting at x/y = 0:

```{r}
ggplot(data = australia_koala_area)+
  geom_sf(size = 0.3, fill = 'white')+
  geom_sf(data = koala_sf, size = 2, aes(color = sex), show.legend = "point")+
  theme_minimal()+
  coord_sf(crs = 4326)+
  theme(panel.background = element_rect(fill = 'steelblue2'))+
  scale_x_continuous(expand = c(0,0))+
  scale_y_continuous(expand = c(0,0))
```

When working with these types of maps, you will often be asked to create an inset map that shows the entire area that you cropped from for reference. Let's add a little Australia shape with a bounding box of our study area to our map. First we need to create the a base map with bounding box and save it to the environment:

```{r}
inset<-ggplot(data = states_proj, show.legend = "point")+
  geom_sf()+
  geom_rect(xmin = extent(australia_koala_area)[1], xmax = extent(australia_koala_area)[2],
            ymin = extent(australia_koala_area)[3], ymax = extent(australia_koala_area)[4],
            fill = NA,  colour = "black", size = 1.5)+
  labs(x = '', y = '', title = '')+
  coord_sf(crs = 4326)+
  theme_void()

inset
```

`geom_rect` can create any rectangular shape within your ggplot based on `xmin`, `xmax` and so on. Since these are dependent on your scales, for mapping we can use the `extent` of our cropped area from before. `extent()` is part of the `raster` package:

```{r}
extent(australia_koala_area)
```

By using `[1]`, `[2]` and so on, we call the respective coordinate from the four rows that this function is giving us. Using `theme_void()` is getting rid of any axis and grids, so that we have the map only. We also need to save our map as an object:

```{r}
map<-ggplot(data = australia_koala_area)+
  geom_sf(size = 0.3, fill = 'white')+
  geom_sf(data = koala_sf, size = 2, aes(color = sex), show.legend = "point")+
  theme_minimal()+
  coord_sf(crs = 4326)+
  theme(panel.background = element_rect(fill = 'steelblue2'))+  
  scale_x_continuous(expand = c(0,0))+
  scale_y_continuous(expand = c(0,0))
```

We use `annotation_custom()` and `ggplotGrob()` to place an inset into the main map:

```{r}
map+annotation_custom(ggplotGrob(inset), xmin = 139, xmax = 144, ymin = -26, ymax = -20)
```

The size and position here is defined by `xmin = ` etc. This needs a bit of fiddling around to get it right. Also be mindful that we are using a Mercator projection here and are in the southern hemisphere, so our `ymin` and `ymax` values need to be given in negative form. Now this is a proper map, ready to be put in your next publication! We will briefly talk about rasters, because you are likely to use them if you are working with shapefiles anyway. It is similarly easy to work with rasters in `R`:

## `R` raster basics

Raster support in `R` is made available using the package `raster`. One called, we can load and plot a raster using the same command. Let's get our DEM to play with:

```{r}
dem<-raster('data/DEM.tif')

summary(dem)

plot(dem)
```

In a raster, cell (or pixel) has a spatial reference and a value. In this case we have the elevation in meters for each degree (`r res(dem)`) in southeastern Australia.

Let's say we're only interested in Victoria. We can use a spatial vector to  mask out the state area from the raster. First we need to create a mask. We already know that our Australia shapefile contains a `STATE` column. We can use that to subset the shapefile and use the subset as a mask. Simple `dplyr` commands and `%>%` work on `sf` features, which makes working with them so easy in `R`!

```{r}
vic<-states_proj%>%filter(STATENAME == 'Victoria')%>%st_transform(crs = st_crs(dem)) # we also transform the crs to be sure they match

plot(dem)
plot(vic$geometry, add = T)
```

To remove anything outside of Victoria, we use `raster`'s `mask()` and end up with the DEM for Victoria only:

```{r}
dem_vic<-mask(dem, vic)

plot(dem_vic)
```

We can now also filter our koala dataset to only have koalas in Victoria to plot over our DEM.

```{r}
koala_vic<-koala_sf%>%filter(state == 'Victoria')%>%st_transform(crs = st_crs(dem))

plot(dem_vic)

plot(koala_vic$geometry, color = 'black', add = T)
```

Often we are using rasters and spatial vector data together to extract data that is generally stored in raster form (such as elevation, mean temperatures or other topographic variables). For example if we are interested to see at which elevation our Koalas were observed in Victoria to make assumptions about their habitat preferences or temperature tolerances. If the CRS of both the raster and shapefile match, we can use `extract()` to add data from the raster to our spatial points as a new column:

```{r}
koala_vic$ele<-raster::extract(dem_vic, koala_vic)

summary(koala_vic$ele)

hist(koala_vic$ele)
```

We can see most observations were made below 200 meters. The median elevation for koalas in our dataset was `r round(median(koala_vic$ele))`. Again if we want to make nice and informative maps out of rasters, even in combination with spatial vector data, `ggplot2` is the way to go!

## Plotting rasters in `ggplot2`

Before we can plot a raster, we have to make it into a `data.frame` containing of columns `X` and `Y` as coordinates and a column containing the raster value of each pixel. Since rasters can be large and the resulting dataframes even larger, we first take a sample of the raster, which reduces the resolution:

```{r}
sample_raster<-sampleRegular(dem_vic, size = 5e5, asRaster = TRUE) %>%
  as.data.frame(xy = TRUE, na.rm = TRUE)%>%
  setNames(c('x', 'y', 'layer'))
```

Make sure to always use `xy = TRUE`, so that the coordinates are included in the new `data.frame`. We now have a format that ggplot can work with using `geom_raster()` 

```{r, echo=F}
head(sample_raster)
```

```{r}
ggplot(data = sample_raster, aes ( x = x, y = y, fill = layer))+
  geom_raster()
```

Let's make it look a bit prettier. The package `viridis` offers a few great color palettes for gradients of continuous variables:

```{r}
ggplot(data = sample_raster, aes ( x = x, y = y, fill = layer))+
  geom_raster()+
  scale_fill_viridis(option = 'A')+
  labs(x = 'Longitude', y = 'Latitude', fill = 'Elevation')+
  coord_sf(crs = 4326)+
  theme_bw()
```

We can plot additional layers on top of the raster by adding more `geom_`'s. That means we can plot rasters and spatial vectors together to make great maps for your papers and reports. I'm sure you can figure it out yourself for the next and final challenge!

### Challenge 3

**Add koala observations, color points by a categorical variable of your choice and change the color scheme.**

*hint: to add different types of data, each data layer needs its own data source!:*
*(geom_raster(data = sample_raster, aes(x = x, y = y, fill = layer))+...*)

```{r}
ggplot()+
  geom_raster(data = sample_raster, aes(x = x, y = y, fill = layer))+
  geom_sf(data=koala_vic, size = 2, aes(color = sex), show.legend = "point")+
  scale_fill_viridis(option = "D") +
  labs(x = "Longitude", 
       y = "Latitude", 
       fill = "Elevation") +
  coord_sf(crs = 4326) +
  theme_bw()

```

## Solutions to Challenges

### Challenge 1

```{r, eval = F}
states_proj <- st_transform(states, crs = st_crs(koala_sf))

plot(st_geometry(states_proj), 
     axes = TRUE)

plot(st_geometry(koala_sf), 
     col = koala_sf$state, 
     add = T)
```

### Challenge 2

```{r, eval = F}
ggplot(data = australia_koala_area)+
  geom_sf(size = 0.3, fill = 'white')+
  geom_sf(data = koala_sf, size = 2, aes(color = sex))+
  theme_minimal()+
  coord_sf(crs = 4326)+
  theme(panel.background = element_rect(fill = 'steelblue2'))
```

### Challenge 3

```{r, eval = F}
ggplot()+
  geom_raster(data = sample_raster, aes(x = x, y = y, fill = layer))+
  geom_sf(data=koala_vic, size = 2, aes(color = sex), show.legend = "point")+
  scale_fill_viridis(option = "D") +
  labs(x = "Longitude", 
       y = "Latitude", 
       fill = "Elevation") +
  coord_sf(crs = 4326) +
  theme_bw()
```

<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 9 Spatial tools for forestry and ecological applications | Intro to R for Forest Ecosystem Science</title>
  <meta name="description" content="Introductory R" />
  <meta name="generator" content="bookdown 0.18 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 9 Spatial tools for forestry and ecological applications | Intro to R for Forest Ecosystem Science" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Introductory R" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 9 Spatial tools for forestry and ecological applications | Intro to R for Forest Ecosystem Science" />
  
  <meta name="twitter:description" content="Introductory R" />
  

<meta name="author" content="Anu Singh, Benjamin Wagner, and Kaitlyn Hammond" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="working-with-spatial-data-in-r.html"/>
<link rel="next" href="extracting-raster-fractions-and-area-using-a-polygon-mask.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<script src="libs/kePrint-0.0.1/kePrint.js"></script>


<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#disclaimer"><i class="fa fa-check"></i><b>1.1</b> Disclaimer</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="a-few-words-on-a-productive-setup-and-workflow-in-r-with-r-studio.html"><a href="a-few-words-on-a-productive-setup-and-workflow-in-r-with-r-studio.html"><i class="fa fa-check"></i><b>2</b> A few words on a productive setup and workflow in <code>R</code> with <em>R-Studio</em></a><ul>
<li class="chapter" data-level="2.1" data-path="a-few-words-on-a-productive-setup-and-workflow-in-r-with-r-studio.html"><a href="a-few-words-on-a-productive-setup-and-workflow-in-r-with-r-studio.html#r-projects"><i class="fa fa-check"></i><b>2.1</b> R Projects</a></li>
<li class="chapter" data-level="2.2" data-path="a-few-words-on-a-productive-setup-and-workflow-in-r-with-r-studio.html"><a href="a-few-words-on-a-productive-setup-and-workflow-in-r-with-r-studio.html#setting-up-the-r-studio-user-interface"><i class="fa fa-check"></i><b>2.2</b> Setting up the R-Studio User interface</a></li>
<li class="chapter" data-level="2.3" data-path="a-few-words-on-a-productive-setup-and-workflow-in-r-with-r-studio.html"><a href="a-few-words-on-a-productive-setup-and-workflow-in-r-with-r-studio.html#code-folds-and-commenting"><i class="fa fa-check"></i><b>2.3</b> Code folds and commenting</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="introducing-the-koala-dataset.html"><a href="introducing-the-koala-dataset.html"><i class="fa fa-check"></i><b>3</b> Introducing the koala dataset</a><ul>
<li class="chapter" data-level="3.1" data-path="introducing-the-koala-dataset.html"><a href="introducing-the-koala-dataset.html#data-types-and-variable-types"><i class="fa fa-check"></i><b>3.1</b> <em>data types</em> and <em>variable types</em></a></li>
<li class="chapter" data-level="3.2" data-path="introducing-the-koala-dataset.html"><a href="introducing-the-koala-dataset.html#changing-variable-types"><i class="fa fa-check"></i><b>3.2</b> Changing <em>variable types</em></a></li>
<li class="chapter" data-level="3.3" data-path="introducing-the-koala-dataset.html"><a href="introducing-the-koala-dataset.html#how-the-koala-dataset-was-collated"><i class="fa fa-check"></i><b>3.3</b> How the koala dataset was collated</a><ul>
<li class="chapter" data-level="3.3.1" data-path="introducing-the-koala-dataset.html"><a href="introducing-the-koala-dataset.html#loading-the-raw-data"><i class="fa fa-check"></i><b>3.3.1</b> Loading the raw data</a></li>
<li class="chapter" data-level="3.3.2" data-path="introducing-the-koala-dataset.html"><a href="introducing-the-koala-dataset.html#adding-the-state-names-by-location"><i class="fa fa-check"></i><b>3.3.2</b> Adding the state names by location</a></li>
<li class="chapter" data-level="3.3.3" data-path="introducing-the-koala-dataset.html"><a href="introducing-the-koala-dataset.html#creating-dummy-data"><i class="fa fa-check"></i><b>3.3.3</b> Creating dummy data</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><a href="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><i class="fa fa-check"></i><b>4</b> <code>dplyr</code> - A brief introduction to tidy data manipulation</a><ul>
<li class="chapter" data-level="4.1" data-path="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><a href="dplyr-a-brief-introduction-to-tidy-data-manipulation.html#loading-and-checking-the-data"><i class="fa fa-check"></i><b>4.1</b> Loading and checking the data</a></li>
<li class="chapter" data-level="4.2" data-path="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><a href="dplyr-a-brief-introduction-to-tidy-data-manipulation.html#working-with-dplyr"><i class="fa fa-check"></i><b>4.2</b> Working with <code>dplyr</code></a><ul>
<li class="chapter" data-level="4.2.1" data-path="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><a href="dplyr-a-brief-introduction-to-tidy-data-manipulation.html#select-and-dplyrs-pipe"><i class="fa fa-check"></i><b>4.2.1</b> select() and dplyr’s pipe</a></li>
<li class="chapter" data-level="4.2.2" data-path="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><a href="dplyr-a-brief-introduction-to-tidy-data-manipulation.html#filter"><i class="fa fa-check"></i><b>4.2.2</b> filter()</a></li>
<li class="chapter" data-level="4.2.3" data-path="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><a href="dplyr-a-brief-introduction-to-tidy-data-manipulation.html#challenge-1"><i class="fa fa-check"></i><b>4.2.3</b> Challenge 1</a></li>
<li class="chapter" data-level="4.2.4" data-path="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><a href="dplyr-a-brief-introduction-to-tidy-data-manipulation.html#group_by-and-summarise"><i class="fa fa-check"></i><b>4.2.4</b> group_by() and summarise()</a></li>
<li class="chapter" data-level="4.2.5" data-path="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><a href="dplyr-a-brief-introduction-to-tidy-data-manipulation.html#challenge-2"><i class="fa fa-check"></i><b>4.2.5</b> Challenge 2</a></li>
<li class="chapter" data-level="4.2.6" data-path="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><a href="dplyr-a-brief-introduction-to-tidy-data-manipulation.html#mutate"><i class="fa fa-check"></i><b>4.2.6</b> mutate()</a></li>
<li class="chapter" data-level="4.2.7" data-path="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><a href="dplyr-a-brief-introduction-to-tidy-data-manipulation.html#challenge-3"><i class="fa fa-check"></i><b>4.2.7</b> Challenge 3</a></li>
<li class="chapter" data-level="4.2.8" data-path="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><a href="dplyr-a-brief-introduction-to-tidy-data-manipulation.html#pivoting"><i class="fa fa-check"></i><b>4.2.8</b> Pivoting</a></li>
<li class="chapter" data-level="4.2.9" data-path="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><a href="dplyr-a-brief-introduction-to-tidy-data-manipulation.html#challenge-4"><i class="fa fa-check"></i><b>4.2.9</b> Challenge 4</a></li>
<li class="chapter" data-level="4.2.10" data-path="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><a href="dplyr-a-brief-introduction-to-tidy-data-manipulation.html#challenge-5"><i class="fa fa-check"></i><b>4.2.10</b> Challenge 5</a></li>
<li class="chapter" data-level="4.2.11" data-path="dplyr-a-brief-introduction-to-tidy-data-manipulation.html"><a href="dplyr-a-brief-introduction-to-tidy-data-manipulation.html#solution-to-all-challenges"><i class="fa fa-check"></i><b>4.2.11</b> Solution to all challenges</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="introduction-to-data-visualization-in-ggplot2.html"><a href="introduction-to-data-visualization-in-ggplot2.html"><i class="fa fa-check"></i><b>5</b> Introduction to data visualization in <code>ggplot2</code></a></li>
<li class="chapter" data-level="6" data-path="introduction-to-linear-models-in-r.html"><a href="introduction-to-linear-models-in-r.html"><i class="fa fa-check"></i><b>6</b> Introduction to linear models in R</a></li>
<li class="chapter" data-level="7" data-path="functions-in-r.html"><a href="functions-in-r.html"><i class="fa fa-check"></i><b>7</b> Functions in R</a><ul>
<li class="chapter" data-level="7.1" data-path="functions-in-r.html"><a href="functions-in-r.html#introduction-1"><i class="fa fa-check"></i><b>7.1</b> Introduction</a><ul>
<li class="chapter" data-level="7.1.1" data-path="functions-in-r.html"><a href="functions-in-r.html#mathematical-operations"><i class="fa fa-check"></i><b>7.1.1</b> Mathematical operations</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="functions-in-r.html"><a href="functions-in-r.html#what-is-an-r-function"><i class="fa fa-check"></i><b>7.2</b> What is an R function?</a></li>
<li class="chapter" data-level="7.3" data-path="functions-in-r.html"><a href="functions-in-r.html#nesting-functions"><i class="fa fa-check"></i><b>7.3</b> Nesting functions</a><ul>
<li class="chapter" data-level="7.3.1" data-path="functions-in-r.html"><a href="functions-in-r.html#some-basic-built-in-mathematical-functions"><i class="fa fa-check"></i><b>7.3.1</b> Some basic built-in mathematical functions</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="functions-in-r.html"><a href="functions-in-r.html#assigning-variables-within-functions"><i class="fa fa-check"></i><b>7.4</b> Assigning variables within functions</a></li>
<li class="chapter" data-level="7.5" data-path="functions-in-r.html"><a href="functions-in-r.html#challenge-1-2"><i class="fa fa-check"></i><b>7.5</b> Challenge 1</a></li>
<li class="chapter" data-level="7.6" data-path="functions-in-r.html"><a href="functions-in-r.html#using-return"><i class="fa fa-check"></i><b>7.6</b> Using <code>return()</code></a></li>
<li class="chapter" data-level="7.7" data-path="functions-in-r.html"><a href="functions-in-r.html#challenge-2-2"><i class="fa fa-check"></i><b>7.7</b> Challenge 2</a></li>
<li class="chapter" data-level="7.8" data-path="functions-in-r.html"><a href="functions-in-r.html#solutions-to-challenges"><i class="fa fa-check"></i><b>7.8</b> Solutions to challenges</a><ul>
<li class="chapter" data-level="7.8.1" data-path="functions-in-r.html"><a href="functions-in-r.html#challenge-1-3"><i class="fa fa-check"></i><b>7.8.1</b> Challenge 1</a></li>
<li class="chapter" data-level="7.8.2" data-path="functions-in-r.html"><a href="functions-in-r.html#challenge-2-3"><i class="fa fa-check"></i><b>7.8.2</b> Challenge 2</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="working-with-spatial-data-in-r.html"><a href="working-with-spatial-data-in-r.html"><i class="fa fa-check"></i><b>8</b> Working with spatial data in <code>R</code></a><ul>
<li class="chapter" data-level="8.1" data-path="working-with-spatial-data-in-r.html"><a href="working-with-spatial-data-in-r.html#transforming-a-dataset-into-an-sf-object"><i class="fa fa-check"></i><b>8.1</b> Transforming a dataset into an <code>sf</code> object</a></li>
<li class="chapter" data-level="8.2" data-path="working-with-spatial-data-in-r.html"><a href="working-with-spatial-data-in-r.html#loading-shapefiles-into-r-transforming-and-plotting"><i class="fa fa-check"></i><b>8.2</b> Loading shapefiles into <code>R</code>, transforming and plotting</a><ul>
<li class="chapter" data-level="8.2.1" data-path="working-with-spatial-data-in-r.html"><a href="working-with-spatial-data-in-r.html#challenge-1-4"><i class="fa fa-check"></i><b>8.2.1</b> Challenge 1</a></li>
</ul></li>
<li class="chapter" data-level="8.3" data-path="working-with-spatial-data-in-r.html"><a href="working-with-spatial-data-in-r.html#simple-geometric-operations"><i class="fa fa-check"></i><b>8.3</b> Simple geometric operations</a></li>
<li class="chapter" data-level="8.4" data-path="working-with-spatial-data-in-r.html"><a href="working-with-spatial-data-in-r.html#making-a-map-using-ggplot2"><i class="fa fa-check"></i><b>8.4</b> Making a map using <code>ggplot2</code></a><ul>
<li class="chapter" data-level="8.4.1" data-path="working-with-spatial-data-in-r.html"><a href="working-with-spatial-data-in-r.html#challenge-2-4"><i class="fa fa-check"></i><b>8.4.1</b> Challenge 2</a></li>
</ul></li>
<li class="chapter" data-level="8.5" data-path="working-with-spatial-data-in-r.html"><a href="working-with-spatial-data-in-r.html#r-raster-basics"><i class="fa fa-check"></i><b>8.5</b> <code>R</code> raster basics</a></li>
<li class="chapter" data-level="8.6" data-path="working-with-spatial-data-in-r.html"><a href="working-with-spatial-data-in-r.html#plotting-rasters-in-ggplot2"><i class="fa fa-check"></i><b>8.6</b> Plotting rasters in <code>ggplot2</code></a><ul>
<li class="chapter" data-level="8.6.1" data-path="working-with-spatial-data-in-r.html"><a href="working-with-spatial-data-in-r.html#challenge-3-2"><i class="fa fa-check"></i><b>8.6.1</b> Challenge 3</a></li>
</ul></li>
<li class="chapter" data-level="8.7" data-path="working-with-spatial-data-in-r.html"><a href="working-with-spatial-data-in-r.html#solutions-to-challenges-1"><i class="fa fa-check"></i><b>8.7</b> Solutions to Challenges</a><ul>
<li class="chapter" data-level="8.7.1" data-path="working-with-spatial-data-in-r.html"><a href="working-with-spatial-data-in-r.html#challenge-1-5"><i class="fa fa-check"></i><b>8.7.1</b> Challenge 1</a></li>
<li class="chapter" data-level="8.7.2" data-path="working-with-spatial-data-in-r.html"><a href="working-with-spatial-data-in-r.html#challenge-2-5"><i class="fa fa-check"></i><b>8.7.2</b> Challenge 2</a></li>
<li class="chapter" data-level="8.7.3" data-path="working-with-spatial-data-in-r.html"><a href="working-with-spatial-data-in-r.html#challenge-3-3"><i class="fa fa-check"></i><b>8.7.3</b> Challenge 3</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="9" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html"><i class="fa fa-check"></i><b>9</b> Spatial tools for forestry and ecological applications</a><ul>
<li class="chapter" data-level="9.1" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#an-introduction-to-processing-lidar-data-in-r"><i class="fa fa-check"></i><b>9.1</b> An introduction to processing LiDAR data in <code>R</code></a></li>
<li class="chapter" data-level="9.2" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#working-with-lidar-data-in-r"><i class="fa fa-check"></i><b>9.2</b> Working with LiDAR data in R</a></li>
<li class="chapter" data-level="9.3" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#step-1.-loading-and-visualizing-pointclouds"><i class="fa fa-check"></i><b>9.3</b> Step 1. Loading and visualizing pointclouds</a></li>
<li class="chapter" data-level="9.4" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#step-2.-computing-a-canopy-height-model"><i class="fa fa-check"></i><b>9.4</b> Step 2. Computing a canopy height model</a><ul>
<li class="chapter" data-level="9.4.1" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#ground-detection-and-normalizing-a-point-cloud"><i class="fa fa-check"></i><b>9.4.1</b> Ground detection and normalizing a point cloud</a></li>
<li class="chapter" data-level="9.4.2" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#building-the-initial-chm"><i class="fa fa-check"></i><b>9.4.2</b> Building the initial CHM</a></li>
<li class="chapter" data-level="9.4.3" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#challenge-1-6"><i class="fa fa-check"></i><b>9.4.3</b> Challenge 1</a></li>
</ul></li>
<li class="chapter" data-level="9.5" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#step-3.-individual-tree-segmentation"><i class="fa fa-check"></i><b>9.5</b> Step 3. Individual tree segmentation</a><ul>
<li class="chapter" data-level="9.5.1" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#delineating-the-crowns"><i class="fa fa-check"></i><b>9.5.1</b> Delineating the crowns</a></li>
<li class="chapter" data-level="9.5.2" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#challenge-2-6"><i class="fa fa-check"></i><b>9.5.2</b> Challenge 2</a></li>
</ul></li>
<li class="chapter" data-level="9.6" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#additional-analysis-computing-a-digital-terrain-model-dtm"><i class="fa fa-check"></i><b>9.6</b> Additional analysis: Computing a digital terrain model (DTM)</a><ul>
<li class="chapter" data-level="9.6.1" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#challenge-3-4"><i class="fa fa-check"></i><b>9.6.1</b> Challenge 3</a></li>
</ul></li>
<li class="chapter" data-level="9.7" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#wrapping-up"><i class="fa fa-check"></i><b>9.7</b> Wrapping up</a></li>
<li class="chapter" data-level="9.8" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#solutions-to-the-challenges"><i class="fa fa-check"></i><b>9.8</b> Solutions to the challenges</a><ul>
<li class="chapter" data-level="9.8.1" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#challenge-1-7"><i class="fa fa-check"></i><b>9.8.1</b> Challenge 1</a></li>
<li class="chapter" data-level="9.8.2" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#challenge-2-7"><i class="fa fa-check"></i><b>9.8.2</b> Challenge 2</a></li>
<li class="chapter" data-level="9.8.3" data-path="spatial-tools-for-forestry-and-ecological-applications.html"><a href="spatial-tools-for-forestry-and-ecological-applications.html#challenge-3-5"><i class="fa fa-check"></i><b>9.8.3</b> Challenge 3</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="10" data-path="extracting-raster-fractions-and-area-using-a-polygon-mask.html"><a href="extracting-raster-fractions-and-area-using-a-polygon-mask.html"><i class="fa fa-check"></i><b>10</b> Extracting raster fractions and area using a polygon mask</a><ul>
<li class="chapter" data-level="10.1" data-path="extracting-raster-fractions-and-area-using-a-polygon-mask.html"><a href="extracting-raster-fractions-and-area-using-a-polygon-mask.html#problem-statement"><i class="fa fa-check"></i><b>10.1</b> Problem statement</a></li>
<li class="chapter" data-level="10.2" data-path="extracting-raster-fractions-and-area-using-a-polygon-mask.html"><a href="extracting-raster-fractions-and-area-using-a-polygon-mask.html#creating-some-dummy-raster-data"><i class="fa fa-check"></i><b>10.2</b> Creating some dummy raster data</a></li>
<li class="chapter" data-level="10.3" data-path="extracting-raster-fractions-and-area-using-a-polygon-mask.html"><a href="extracting-raster-fractions-and-area-using-a-polygon-mask.html#create-some-reserves"><i class="fa fa-check"></i><b>10.3</b> Create some reserves</a></li>
<li class="chapter" data-level="10.4" data-path="extracting-raster-fractions-and-area-using-a-polygon-mask.html"><a href="extracting-raster-fractions-and-area-using-a-polygon-mask.html#extracting-data"><i class="fa fa-check"></i><b>10.4</b> Extracting data</a></li>
<li class="chapter" data-level="10.5" data-path="extracting-raster-fractions-and-area-using-a-polygon-mask.html"><a href="extracting-raster-fractions-and-area-using-a-polygon-mask.html#plotting-the-results"><i class="fa fa-check"></i><b>10.5</b> Plotting the results</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="calculating-class-area-from-raster.html"><a href="calculating-class-area-from-raster.html"><i class="fa fa-check"></i><b>11</b> Calculating class area from raster</a><ul>
<li class="chapter" data-level="11.1" data-path="calculating-class-area-from-raster.html"><a href="calculating-class-area-from-raster.html#simple-area-and-area-fraction-calculations-on-a-classified-raster"><i class="fa fa-check"></i><b>11.1</b> Simple area and area fraction calculations on a classified raster</a><ul>
<li class="chapter" data-level="11.1.1" data-path="calculating-class-area-from-raster.html"><a href="calculating-class-area-from-raster.html#creating-dummy-data-1"><i class="fa fa-check"></i><b>11.1.1</b> Creating dummy data</a></li>
<li class="chapter" data-level="11.1.2" data-path="calculating-class-area-from-raster.html"><a href="calculating-class-area-from-raster.html#preparing-the-raster-for-area-calculation"><i class="fa fa-check"></i><b>11.1.2</b> Preparing the raster for area calculation</a></li>
<li class="chapter" data-level="11.1.3" data-path="calculating-class-area-from-raster.html"><a href="calculating-class-area-from-raster.html#compiling-a-comprehensive-table"><i class="fa fa-check"></i><b>11.1.3</b> Compiling a comprehensive table</a></li>
</ul></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Intro to R for Forest Ecosystem Science</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="spatial-tools-for-forestry-and-ecological-applications" class="section level1">
<h1><span class="header-section-number">Chapter 9</span> Spatial tools for forestry and ecological applications</h1>
<p><img src="data/lidR-doc/pc.gif" width="300" style="display: block; margin: auto;" /></p>
<div id="an-introduction-to-processing-lidar-data-in-r" class="section level2">
<h2><span class="header-section-number">9.1</span> An introduction to processing LiDAR data in <code>R</code></h2>
<p><em>NOTE: This tutorial is based on <code>lidR</code> function Syntax pre version 3.0. Older function names have been depreceated, but are still working, thus not affecting the workflow of this tutorial. Nevertheless, befor you start working on your own data, you might want to check for updated function names and new functionalites in lidR 3.0 <a href="https://github.com/Jean-Romain/lidR/blob/master/NEWS.md">here</a>.</em></p>
</div>
<div id="working-with-lidar-data-in-r" class="section level2">
<h2><span class="header-section-number">9.2</span> Working with LiDAR data in R</h2>
<p><code>lidR</code> is a R package to process, manipulate and visualize LiDAR (and photogrammetry) pointclouds for forestry applications. Useful functionality includes the simple and memory-efficient plotting and visualization of data, computation of canopy height models (CHMs), tree segmentation and the extraction of tree metrics such as tree height and crown area. For more advanced users it additionally offers batch functionality, called cataloging, to process large LiDAR chunks, which otherwise would be very computation intensive.</p>
<p>This tutorial is a quick guide to getting familiar with the main functionality of <code>lidR</code> and based on the excellent package documentation that can be found <a href="https://github.com/Jean-Romain/lidR/wiki">here</a>. You can find the github page for <code>lidR</code> at <strong><a href="https://github.com/Jean-Romain/lidR" class="uri">https://github.com/Jean-Romain/lidR</a></strong> and the package documentation at <strong><a href="https://cran.r-project.org/web/packages/lidR/lidR.pdf" class="uri">https://cran.r-project.org/web/packages/lidR/lidR.pdf</a></strong>.</p>
<p>We will be working with two example files (<code>Example.las</code> and <code>drawno.laz</code>), that you need to store in a <code>data/</code> folder in your project (or working) directory. The files can be downloaded <a href="https://www.dropbox.com/s/65yjdewy0c2n3lf/data.rar?dl=1">here</a>. Please make sure that you have downloaded and stored the two files before beginning the tutorial. You also need to install the following packages:</p>
<div class="sourceCode" id="cb265"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb265-1" title="1"><span class="kw">install.packages</span>(<span class="kw">c</span>(<span class="st">&#39;lidR&#39;</span>, <span class="st">&#39;raster&#39;</span>, <span class="st">&#39;rgdal&#39;</span>, <span class="st">&#39;dplyr&#39;</span>, <span class="st">&#39;sf&#39;</span>))</a></code></pre></div>
<p>We will also need the package <code>EBImage</code> for our tree segmentation, which is distributed as part of the <a href="http://bioconductor.org/packages/release/bioc/html/EBImage.html">Bioconductor</a> project. To install, run the following code:</p>
<div class="sourceCode" id="cb266"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb266-1" title="1"><span class="kw">install.packages</span>(<span class="st">&quot;BiocManager&quot;</span>)</a>
<a class="sourceLine" id="cb266-2" title="2">BiocManager<span class="op">::</span><span class="kw">install</span>(<span class="st">&quot;EBImage&quot;</span>)</a></code></pre></div>
<p>If this prompts you to update existing packages (<code>Update all/some/none? [a/s/n]:</code>) in the console, type <code>n</code> and hit enter. Once all packages are installed, we need to call them:</p>
<div class="sourceCode" id="cb267"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb267-1" title="1"><span class="kw">library</span>(raster)</a>
<a class="sourceLine" id="cb267-2" title="2"><span class="kw">library</span>(EBImage)</a>
<a class="sourceLine" id="cb267-3" title="3"><span class="kw">library</span>(lidR)</a>
<a class="sourceLine" id="cb267-4" title="4"><span class="kw">library</span>(sf)</a>
<a class="sourceLine" id="cb267-5" title="5"><span class="kw">library</span>(rgdal)</a>
<a class="sourceLine" id="cb267-6" title="6"><span class="kw">library</span>(dplyr)</a></code></pre></div>
</div>
<div id="step-1.-loading-and-visualizing-pointclouds" class="section level2">
<h2><span class="header-section-number">9.3</span> Step 1. Loading and visualizing pointclouds</h2>
<p>For those familiar with <code>R</code>, loading and plotting pointcloud files will be easy: we are using simple read and <code>plot</code> syntax. <code>lidR</code> can load both <code>.las</code> and <code>.laz</code> file formats. Let’s read one of our example files and plot it:</p>
<div class="sourceCode" id="cb268"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb268-1" title="1">forest&lt;-<span class="kw">readLAS</span>(<span class="st">&#39;data/drawno.laz&#39;</span>)</a></code></pre></div>
<p>Using <code>print()</code> will give us a bit of information about the file we have just loaded, for example on the number of points and point density.</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb269-1" title="1"><span class="kw">print</span>(forest)</a></code></pre></div>
<pre><code>## class        : LAS (v1.2 format 1)
## memory       : 11.5 Mb 
## extent       : 278200, 278300, 602200, 602300 (xmin, xmax, ymin, ymax)
## coord. ref.  : NA 
## area         : 9996.22 units²
## points       : 150.4 thousand points
## density      : 15.05 points/units²</code></pre>
<p>We can see that this particular file has ~150,000 points with a point density of ~15 per unit. We can also see that there is no coordinate reference system (crs) associated with this file, which is why the unit is unknown. This might lead to issues later on, so always check that your raw pointcloud has a crs assigned, before starting to work with it. For the purpose of this tutorial, we can overlook this. Let’s visualize our pointcloud!</p>
<div class="sourceCode" id="cb271"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb271-1" title="1"><span class="kw">plot</span>(forest)</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-5"></span>
<img src="data/lidR-doc/plot.png" alt="A new window will open and your plot will look something like this" width="500" />
<p class="caption">
Figure 9.1: A new window will open and your plot will look something like this
</p>
</div>
<p>You can change the color of your point cloud using <code>colorPalette =</code>. Make sure to close the previous plot window before plotting a new one. Let’s try a few options:</p>
<div class="sourceCode" id="cb272"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb272-1" title="1"><span class="kw">plot</span>(forest,  <span class="dt">colorPalette =</span> <span class="kw">terrain.colors</span>(<span class="dv">50</span>))</a>
<a class="sourceLine" id="cb272-2" title="2"><span class="kw">plot</span>(forest,  <span class="dt">colorPalette =</span> <span class="kw">heat.colors</span>(<span class="dv">50</span>))</a></code></pre></div>
</div>
<div id="step-2.-computing-a-canopy-height-model" class="section level2">
<h2><span class="header-section-number">9.4</span> Step 2. Computing a canopy height model</h2>
<p>Now that we have imported our LiDAR data in to <code>R</code>, we can start working with it using the functionality of the package. We want to compute a canopy height model (CHM) from our two example files. CHMs are rasterized versions of the forests captured using LiDAR. Each pixel value in this raster describes the height above ground. These CHMs are useful to get an idea about the forest structure of the area we are looking at. A CHM is derived from the pointcloud by subtracting a digital terrain model (DTM) describing the ground topography, from a digital surface model (DSM) describing points of the pointcloud above the ground:</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-6"></span>
<img src="data/lidR-doc/CHM.png" alt="The theory behind a CHM. Graphic: Colin Williams, NEON" width="500" />
<p class="caption">
Figure 9.2: The theory behind a CHM. Graphic: Colin Williams, NEON
</p>
</div>
<div id="ground-detection-and-normalizing-a-point-cloud" class="section level3">
<h3><span class="header-section-number">9.4.1</span> Ground detection and normalizing a point cloud</h3>
<p>While we could now go ahead and calculate a DSM and DTM from our raw pointcloud, <code>lidR</code> has built-in functions to make this easier for us. First of all, we need to normalize our pointcloud, so that all ground points are set to 0. Since you might have noticed that our example forest is already normalized, we will load our other example and start using <code>lasground()</code></p>
<div class="sourceCode" id="cb273"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb273-1" title="1">raw_forest&lt;-<span class="kw">readLAS</span>(<span class="st">&#39;data/Example.las&#39;</span>)</a></code></pre></div>
<p>Do not mind the warnings that pop up. These are associated to the data structure but are not a problem in this case. Let’s have a brief look at what this piece of forest looks like:</p>
<div class="sourceCode" id="cb274"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb274-1" title="1"><span class="kw">plot</span>(raw_forest)</a></code></pre></div>
<p>You will see that the terrain here is a bit undulated. To normalize ground elevation, we first need detect ground points in this raw data and save it as a new pointcloud:</p>
<div class="sourceCode" id="cb275"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb275-1" title="1">raw_forest_ground&lt;-<span class="kw">lasground</span>(raw_forest, <span class="kw">csf</span>())</a></code></pre></div>
<p><code>csf()</code> is one of two ground segmentation algorithms, built into <code>lidR</code>. If you want more detail on what it exactly does, call <code>?csf</code> in the console. We can visualize what this function has done with the raw data by plotting it and coloring it based on the classification we just ran:</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb276-1" title="1"><span class="kw">plot</span>(raw_forest_ground, <span class="dt">color =</span> <span class="st">&quot;Classification&quot;</span>)</a></code></pre></div>
<p>Detected ground points are illustrated in blue, our trees in grey. You can check the same for our other example to confirm that this pointlcoud is already classified as we expected:</p>
<div class="sourceCode" id="cb277"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb277-1" title="1"><span class="kw">plot</span>(forest, <span class="dt">color =</span> <span class="st">&quot;Classification&quot;</span>)</a></code></pre></div>
<p>Now that the points are detected, we can normalize our pointcloud, which sets all ground points to an elevation of 0.</p>
<div class="sourceCode" id="cb278"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb278-1" title="1">raw_forest_norm&lt;-<span class="kw">lasnormalize</span>(raw_forest_ground, <span class="kw">tin</span>())</a></code></pre></div>
<p>Again <code>tin()</code> is the spatial interpolation algorithm at work here. We can see what has happened by plotting our raw and normalized data and comparing the point clouds:</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb279-1" title="1"><span class="kw">plot</span>(raw_forest)</a>
<a class="sourceLine" id="cb279-2" title="2"><span class="kw">plot</span>(raw_forest_norm)</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-13"></span>
<img src="data/lidR-doc/norm.png" alt="We can see that the right, raw data exhibits ground topography, while the right, normalized pointcloud is completely flat" width="800" />
<p class="caption">
Figure 9.3: We can see that the right, raw data exhibits ground topography, while the right, normalized pointcloud is completely flat
</p>
</div>
<p>We need the point cloud to be completely flat, to get the exact height of each tree above ground, without the influence topography might have on tree height. Now we are ready to start working on a CHM!</p>
</div>
<div id="building-the-initial-chm" class="section level3">
<h3><span class="header-section-number">9.4.2</span> Building the initial CHM</h3>
<p>To compute a CHM, we simply apply the <code>grid_canopy()</code> function to the normalized pointcloud, but need to give two extra arguments:</p>
<div class="sourceCode" id="cb280"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb280-1" title="1">chm1 &lt;-<span class="st"> </span><span class="kw">grid_canopy</span>(raw_forest_norm, <span class="fl">0.5</span>, <span class="kw">p2r</span>())</a></code></pre></div>
<p>The first argument is the desired resolution of the output, in our case <code>0.5</code> meters. The second argument is the algorithm to compute the CHM. <code>lidR</code> has multiple algorithms built in, here we are using <code>p2r()</code> which attributes the height of the highest point found for each pixel of the output raster. Let’s look at our result:</p>
<div class="sourceCode" id="cb281"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb281-1" title="1"><span class="kw">plot</span>(chm1, <span class="dt">col =</span> <span class="kw">height.colors</span>(<span class="dv">50</span>))</a></code></pre></div>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>Hmm, that doesn’t look too great yet. A lot of white space (empty pixels) indicates that we have pits resulting from the relatively low point density of this point cloud. These will lead to a lot of <code>NA</code> data later on, messing with our analyses, so we should aim at closing these pits by playing around with the arguments within the <code>grid_canopy()</code> function. A simple improvement proposed by Martin Isenburg in <a href="https://rapidlasso.com/2014/11/04/rasterizing-perfect-canopy-height-models-from-lidar/">lastools</a> (the underlying software to <code>lidR</code>) can be obtained by replacing each LiDAR return with a small disk. Since a laser has a width and a footprint, this tweak may simulate this fact. We add a subcircle of <code>0.2</code> diameter in our <code>p2r()</code> algorithm and can see what happens.</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb282-1" title="1">chm2 &lt;-<span class="st"> </span><span class="kw">grid_canopy</span>(raw_forest_norm, <span class="fl">0.5</span>, <span class="kw">p2r</span>(<span class="fl">0.2</span>))</a>
<a class="sourceLine" id="cb282-2" title="2"></a>
<a class="sourceLine" id="cb282-3" title="3"><span class="kw">plot</span>(chm2, <span class="dt">col =</span> <span class="kw">height.colors</span>(<span class="dv">50</span>))</a></code></pre></div>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>That looks much better already, but some pits still persist. Next we can try reducing the resolution a bit to counter these remaining empty pixels:</p>
<div class="sourceCode" id="cb283"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb283-1" title="1">chm3 &lt;-<span class="st"> </span><span class="kw">grid_canopy</span>(raw_forest_norm, <span class="fl">0.75</span>, <span class="kw">p2r</span>(<span class="fl">0.2</span>))</a>
<a class="sourceLine" id="cb283-2" title="2"></a>
<a class="sourceLine" id="cb283-3" title="3"><span class="kw">plot</span>(chm3, <span class="dt">col =</span> <span class="kw">height.colors</span>(<span class="dv">50</span>))</a></code></pre></div>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<p>More pits closed, great! We might loose some detail here, as the pixel size is now larger, but we gain detail from replacing <code>NA</code>’s with height values. Note that playing around with these two parameters might take a while but eventually you may find the right approach that fits your data.</p>
<p>Another popular approach to avoid the empty pixel problem consists of the interpolation of first returns with a triangulated irregular network (TIN) and then rasterizing it onto a grid to create the CHM. For this we need to use the algorithm <code>dstmin()</code> in <code>grid_canopy()</code>:</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb284-1" title="1">chm4 &lt;-<span class="st"> </span><span class="kw">grid_canopy</span>(raw_forest_norm, <span class="fl">0.5</span>, <span class="kw">dsmtin</span>())</a>
<a class="sourceLine" id="cb284-2" title="2"></a>
<a class="sourceLine" id="cb284-3" title="3"><span class="kw">plot</span>(chm4, <span class="dt">col =</span> <span class="kw">height.colors</span>(<span class="dv">50</span>))</a></code></pre></div>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<p>As explained by Martin Isenburg, the result has no more empty pixels but is full of pits because <em>many laser pulses manage to deeply penetrate the canopy before producing the first return</em>. In the end you might need to apply multiple algorithms and functions to reach the best results. Here is just an example of how this might look like, using multiple options to get a decent result for this pointcloud:</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb285-1" title="1">algo &lt;-<span class="st"> </span><span class="kw">pitfree</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">10</span>,<span class="dv">15</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="dt">subcircle =</span> <span class="fl">0.2</span>)</a>
<a class="sourceLine" id="cb285-2" title="2">chm5  &lt;-<span class="st"> </span><span class="kw">grid_canopy</span>(raw_forest_norm, <span class="fl">0.5</span>, algo) </a></code></pre></div>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<p>If you are interested in what you can do to improve your CHM, try <code>?grid_canopy</code> and have a look at the options available. Once we are happy with our CHM, we can have a look at some simple height stats by running <code>summary()</code> for this chunk of forest:</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb286-1" title="1"><span class="kw">summary</span>(chm5)</a></code></pre></div>
<pre><code>##                  Z
## Min.      -0.14362
## 1st Qu.    0.00000
## Median    10.24074
## 3rd Qu.   21.64095
## Max.      52.24510
## NA&#39;s    1808.00000</code></pre>
<p>Let’s test our knowledge and create a CHM for the other example file!</p>
</div>
<div id="challenge-1-6" class="section level3">
<h3><span class="header-section-number">9.4.3</span> Challenge 1</h3>
<p><strong>Produce a CHM for our other example file with as little pits as possible using the functions and algorithm options described above. Keep in mind the initial resolution and point density and play around with the functions having these in mind.</strong> <em>Remember that this pointcloud is already ground normalized, so your might need to adapt the code a bit…</em></p>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<p>Now that is a good looking CHM. Let’s get to using our CHM to segment individual trees as a basis of extracting tree metrics, without having ever to set foot into this forest!</p>
</div>
</div>
<div id="step-3.-individual-tree-segmentation" class="section level2">
<h2><span class="header-section-number">9.5</span> Step 3. Individual tree segmentation</h2>
<p>This step requires us to use a pitfree and smooth canopy height model. Smoothing is a post-process technique using the package <code>raster</code> that aims at removing sharp edges and pixels from the CHM by calculating focal (“moving window”) values for the neighborhood of focal cells using a matrix of weights. Let’s do this in one step to get our tree segmentation on the way:</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb288-1" title="1"><span class="co"># create a new chm to work with</span></a>
<a class="sourceLine" id="cb288-2" title="2"></a>
<a class="sourceLine" id="cb288-3" title="3">algo &lt;-<span class="st"> </span><span class="kw">pitfree</span>(<span class="dt">thresholds =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>,<span class="dv">40</span>,<span class="dv">50</span>), <span class="dt">subcircle =</span> <span class="fl">0.2</span>)</a>
<a class="sourceLine" id="cb288-4" title="4">chm  &lt;-<span class="st"> </span><span class="kw">grid_canopy</span>(raw_forest_norm, <span class="fl">0.5</span>, algo) </a></code></pre></div>
<div class="sourceCode" id="cb289"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb289-1" title="1"><span class="co"># smoothing post-process (here e.g. two pass (running focal twice), 3x3 median convolution)</span></a>
<a class="sourceLine" id="cb289-2" title="2"></a>
<a class="sourceLine" id="cb289-3" title="3">ker &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb289-4" title="4">chm &lt;-<span class="st"> </span><span class="kw">focal</span>(chm, <span class="dt">w =</span> ker, <span class="dt">fun =</span> median)</a>
<a class="sourceLine" id="cb289-5" title="5">chm &lt;-<span class="st"> </span><span class="kw">focal</span>(chm, <span class="dt">w =</span> ker, <span class="dt">fun =</span> median)</a>
<a class="sourceLine" id="cb289-6" title="6"></a>
<a class="sourceLine" id="cb289-7" title="7"><span class="co"># check the smoothed raster</span></a>
<a class="sourceLine" id="cb289-8" title="8"></a>
<a class="sourceLine" id="cb289-9" title="9"><span class="kw">plot</span>(chm, <span class="dt">col =</span> <span class="kw">height.colors</span>(<span class="dv">50</span>)) </a></code></pre></div>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
<p>Comparing this raster to our previous ones, we can see that the ‘fuzziness’ around the edged has been removed. This will aid the next algorithm in finding the trees better. The segmentation using a CHM and normalized pointcloud is implemented in <code>lidR</code> using <code>lastrees()</code>. We will be using a <code>watershed</code> algorithm with a 4 meter threshold. A watershed transformation treats our raster like a topographic map and finds the lines in ‘depressions’ between our trees, treating the tree tops or crowns as ‘ridges’.</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb290-1" title="1"><span class="co"># segment the trees</span></a>
<a class="sourceLine" id="cb290-2" title="2"></a>
<a class="sourceLine" id="cb290-3" title="3">algo &lt;-<span class="st"> </span>lidR<span class="op">::</span><span class="kw">watershed</span>(chm, <span class="dt">th =</span> <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb290-4" title="4">las &lt;-<span class="st"> </span><span class="kw">lastrees</span>(raw_forest_norm, algo)</a>
<a class="sourceLine" id="cb290-5" title="5"></a>
<a class="sourceLine" id="cb290-6" title="6"><span class="co"># remove points that are not assigned to a tree</span></a>
<a class="sourceLine" id="cb290-7" title="7">trees &lt;-<span class="st"> </span><span class="kw">lasfilter</span>(las, <span class="op">!</span><span class="kw">is.na</span>(treeID))</a></code></pre></div>
<p>Let’s have a look at the now segmented pointcloud, which we called <code>trees</code>:</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb291-1" title="1"><span class="kw">plot</span>(trees, <span class="dt">color =</span> <span class="st">&quot;treeID&quot;</span>, <span class="dt">colorPalette =</span> <span class="kw">pastel.colors</span>(<span class="dv">100</span>))</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-28"></span>
<img src="data/lidR-doc/seg.png" alt="Pretty, isn't it? Each tree got a color assigned to it!" width="800" />
<p class="caption">
Figure 9.4: Pretty, isn’t it? Each tree got a color assigned to it!
</p>
</div>
<p>To check how well our tree segmentation performed, we can additional detect the position and center of each tree using <code>tree_detection()</code> and plot these on top of each other for quality control. To extract further structural metrics from our forest, we will need these treetops anyway.</p>
<div class="sourceCode" id="cb292"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb292-1" title="1">treetops&lt;-<span class="kw">tree_detection</span>(raw_forest_norm, <span class="kw">lmf</span>(<span class="dt">ws =</span> <span class="dv">5</span>, <span class="dt">hmin =</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb292-2" title="2"><span class="kw">plot</span>(chm)</a>
<a class="sourceLine" id="cb292-3" title="3"><span class="kw">plot</span>(treetops, <span class="dt">add =</span> T)</a></code></pre></div>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
<p>The arguments that go into the <code>lmf()</code> algorithm describe 1. the length or diameter of the moving window used to detect the local maxima (<code>ws</code>), which corresponds to the crown width. This metric would need to be confirmed by doing some field measurements. And 2. we are using <code>hmin</code> to define the minimum height of a tree in this forest, which we’d also need to ground truth before running this. This is the threshold below which a pixel or a point cannot be a local maxima (and thus a treetop). For this one, we assumed <code>hmin</code> to be 10 meters. If you don’t have ground measurements to tune your algorithm, you need to try a few different values until you’re happy with the results.</p>
<p>We can even plot and evaluate our results in 3D:</p>
<div class="sourceCode" id="cb293"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb293-1" title="1"><span class="kw">plot</span>(trees, <span class="dt">color =</span> <span class="st">&#39;treeID&#39;</span>, <span class="dt">colorPalette =</span> <span class="kw">pastel.colors</span>(<span class="dv">100</span>)) <span class="op">%&gt;%</span><span class="st">  </span><span class="kw">add_treetops3d</span>(treetops)</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-31"></span>
<img src="data/lidR-doc/ttops.png" alt="The treetops as red dots on top of our segmented pointcloud." width="800" />
<p class="caption">
Figure 9.5: The treetops as red dots on top of our segmented pointcloud.
</p>
</div>
<p>To make sure that these results are saved, we should write all these files from the <code>R</code> environment to our hard drive. That will also allow us to e.g. further work with them in a GIS or in a pointcloud viewer such as <a href="https://www.danielgm.net/cc/">CloudCompare</a>. We will create a folder for outputs first, then save our smooth CHM as a raster file (.tif), our normalized pointcloud as a LiDAR file (.las) and the treetops as a shapefile (.shp):</p>
<div class="sourceCode" id="cb294"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb294-1" title="1"><span class="kw">dir.create</span>(<span class="st">&#39;outputs&#39;</span>)</a>
<a class="sourceLine" id="cb294-2" title="2"></a>
<a class="sourceLine" id="cb294-3" title="3"><span class="kw">writeRaster</span>(chm, <span class="st">&#39;outputs/smooth_chm.tif&#39;</span>)</a>
<a class="sourceLine" id="cb294-4" title="4"><span class="kw">writeLAS</span>(raw_forest_norm, <span class="st">&#39;outputs/normalized.las&#39;</span>)</a>
<a class="sourceLine" id="cb294-5" title="5"><span class="kw">writeOGR</span>(treetops, <span class="st">&#39;.&#39;</span>, <span class="st">&#39;outputs/trees.shp&#39;</span>, <span class="dt">driver=</span><span class="st">&quot;ESRI Shapefile&quot;</span>)</a></code></pre></div>
<p>We can now go on and compute some metrics from our segmented trees. We are today especially interested in extracting crown area and height for each of our segmented trees. First we need to derive a polygon for each crown that was segmented. For this <code>lidR</code> offers <code>tree_metrics()</code> and <code>tree_hulls()</code>, which work on the segmented pointcloud we derived earlier. We can then use <code>dplyr</code> to simply join both together to get a polygon shapefile containing crown area and height:</p>
<div class="sourceCode" id="cb295"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb295-1" title="1">metric &lt;-<span class="st"> </span><span class="kw">tree_metrics</span>(trees, .stdtreemetrics)</a>
<a class="sourceLine" id="cb295-2" title="2">hulls  &lt;-<span class="st"> </span><span class="kw">tree_hulls</span>(trees)</a>
<a class="sourceLine" id="cb295-3" title="3"></a>
<a class="sourceLine" id="cb295-4" title="4">hulls<span class="op">@</span>data &lt;-<span class="st"> </span>dplyr<span class="op">::</span><span class="kw">left_join</span>(hulls<span class="op">@</span>data, metric<span class="op">@</span>data)</a></code></pre></div>
<pre><code>## Joining, by = &quot;treeID&quot;</code></pre>
<div class="sourceCode" id="cb297"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb297-1" title="1"><span class="kw">spplot</span>(hulls, <span class="st">&quot;Z&quot;</span>)</a></code></pre></div>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-33-1.png" width="672" /></p>
<p><code>spplot</code> from <code>raster</code> allows us to plot these hulls based on <code>Z</code>, which is the tree height for each of the crowns we identified. We can also plot all these together on our CHM to visually check accuracy:</p>
<div class="sourceCode" id="cb298"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb298-1" title="1"><span class="kw">plot</span>(chm)</a>
<a class="sourceLine" id="cb298-2" title="2"><span class="kw">plot</span>(hulls, <span class="dt">add =</span> T)</a>
<a class="sourceLine" id="cb298-3" title="3"><span class="kw">plot</span>(treetops, <span class="dt">add =</span> T)</a></code></pre></div>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-34-1.png" width="672" /></p>
<p>We can see some of our crowns and tree positions don’t seem quite right, so there might be some room for improvement. But always know that using pointclouds and CHMs is just an approximation of the reality by applying algorithms and models, trying to simulate the measured forest as close as possible. So we will never detect 100% of the trees and we will never delineate them perfectly. Nevertheless, using pointclouds, we will be able to measure thousands of trees in a very brief period of time, while when carrying out forest inventories we can only measure a few dozen per plot, requiring lots of hard labor. A general work flow using ground inventories and LiDAR data together would this be to collect an amount of data needed to get an idea of the structure of your forest on the plot level and tune your LiDAR algorithms by measuring actual trees. Then you can extrapolate your field measurements to a whole forest or larger landscape using the pointclouds collected outside your plot area.</p>
<p>We want to get data on crown area and tree height together in a comprehensive table for further analysis. The <code>raster</code>package will help us calculating the area and converting our polygon shapefile to a simple feature using <code>sf</code> will make it easier to work with the data.</p>
<div class="sourceCode" id="cb299"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb299-1" title="1">hulls<span class="op">$</span>area&lt;-<span class="kw">area</span>(hulls)</a>
<a class="sourceLine" id="cb299-2" title="2"></a>
<a class="sourceLine" id="cb299-3" title="3">tree_metrics&lt;-<span class="kw">st_as_sf</span>(hulls)</a></code></pre></div>
<p><code>sf</code> treats a shapefile’s attribute table like a <code>data.frame</code> and as we can see, the <code>tree_metrics</code> simple feature already contains everything we need:</p>
<div class="sourceCode" id="cb300"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb300-1" title="1"><span class="kw">head</span>(tree_metrics)</a></code></pre></div>
<pre><code>## Simple feature collection with 6 features and 8 fields
## geometry type:  POLYGON
## dimension:      XY
## bbox:           xmin: 488041.5 ymin: 5189194 xmax: 488051.9 ymax: 5189222
## CRS:            +proj=utm +zone=12 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0
##   treeID     XTOP    YTOP   ZTOP      Z npoints convhull_area     area
## 1    332 488046.6 5189194 22.471 22.471     232        41.959 41.95850
## 2    347 488042.0 5189202 22.740 22.740     115        24.596 24.59595
## 3    215 488048.3 5189210 24.805 24.805     156        40.740 40.73950
## 4    351 488041.8 5189208 20.266 20.266      90        21.656 21.65552
## 5    271 488048.1 5189203 22.861 22.861     142        35.895 35.89526
## 6    353 488042.2 5189220 20.852 20.852      49        10.103 10.10254
##                         geometry
## 1 POLYGON ((488051.2 5189196,...
## 2 POLYGON ((488045.7 5189201,...
## 3 POLYGON ((488051.3 5189209,...
## 4 POLYGON ((488045.5 5189207,...
## 5 POLYGON ((488050.8 5189202,...
## 6 POLYGON ((488044.5 5189218,...</code></pre>
<p><code>Z</code> is the height of each tree, identified by <code>treeID</code> and <code>area</code> is the exact area of each tree crown. You may see that <code>convhull_area</code> was already calculated by <code>tree_metrics</code> and corresponds to the area, so we could also use that variable instead and not add a new column. Let’s convert this from a <code>sf</code> to a table and remove all unnecessary information by selecting only the variables we are interested in:</p>
<div class="sourceCode" id="cb302"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb302-1" title="1">tree_table&lt;-<span class="kw">as.data.frame</span>(tree_metrics)<span class="op">%&gt;%</span><span class="kw">select</span>(<span class="st">&#39;treeID&#39;</span>, <span class="st">&#39;Z&#39;</span>, <span class="st">&#39;area&#39;</span>)</a>
<a class="sourceLine" id="cb302-2" title="2"><span class="kw">head</span>(tree_table)</a></code></pre></div>
<pre><code>##   treeID      Z     area
## 1    332 22.471 41.95850
## 2    347 22.740 24.59595
## 3    215 24.805 40.73950
## 4    351 20.266 21.65552
## 5    271 22.861 35.89526
## 6    353 20.852 10.10254</code></pre>
<p>We can now also save the polygon shapefile of our crowns, to have everything ready for GIS processing or inspection. Additionally we want to save our metrics table as a <code>.csv</code>.</p>
<div class="sourceCode" id="cb304"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb304-1" title="1"><span class="kw">st_write</span>(tree_metrics, <span class="st">&#39;outputs/trees_sf.shp&#39;</span>)</a>
<a class="sourceLine" id="cb304-2" title="2"><span class="kw">write.csv</span>(tree_table, <span class="st">&#39;outputs/tree_table.csv&#39;</span>)</a></code></pre></div>
<div id="delineating-the-crowns" class="section level3">
<h3><span class="header-section-number">9.5.1</span> Delineating the crowns</h3>
<p>Now the hulls are great, but for some applications we might actually need to know the exact shape of each tree crown, rather than its approximate hull, for example when studying crown cover or leaf area index (LAI). We can delineate crowns in more detail working directly on the CHM, without the need of using the pointcloud any longer, after we derived the canopy height model. We can apply <code>watershed()</code> directly to the CHM:</p>
<div class="sourceCode" id="cb305"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb305-1" title="1">crowns &lt;-<span class="st"> </span>lidR<span class="op">::</span><span class="kw">watershed</span>(chm, <span class="dt">th =</span> <span class="dv">4</span>)()</a>
<a class="sourceLine" id="cb305-2" title="2"><span class="kw">plot</span>(crowns, <span class="dt">col =</span> <span class="kw">pastel.colors</span>(<span class="dv">100</span>))</a></code></pre></div>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-39-1.png" width="672" /></p>
<p>Now that we have a new raster called <code>crowns</code> where each tree is its own object, we can polygonize it to extract the contours and thus the more precise tree crowns <em>(Note that this might run for a while as it is quite computing intensive)</em>:</p>
<div class="sourceCode" id="cb306"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb306-1" title="1">contour &lt;-<span class="st"> </span><span class="kw">rasterToPolygons</span>(crowns, <span class="dt">dissolve =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb306-2" title="2"></a>
<a class="sourceLine" id="cb306-3" title="3"><span class="kw">plot</span>(chm, <span class="dt">col =</span> <span class="kw">height.colors</span>(<span class="dv">50</span>))</a>
<a class="sourceLine" id="cb306-4" title="4"><span class="kw">plot</span>(contour, <span class="dt">add =</span> T)</a>
<a class="sourceLine" id="cb306-5" title="5"><span class="kw">plot</span>(treetops, <span class="dt">add =</span> T)</a></code></pre></div>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-40-1.png" width="672" /></p>
<p>Before we save this, we need to make sure all our data has the same spatial projection. We can do so using <code>crs()</code>.</p>
<div class="sourceCode" id="cb307"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb307-1" title="1"><span class="kw">crs</span>(chm)</a></code></pre></div>
<pre><code>## CRS arguments:
##  +proj=utm +zone=12 +datum=NAD83 +units=m +no_defs +ellps=GRS80
## +towgs84=0,0,0</code></pre>
<div class="sourceCode" id="cb309"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb309-1" title="1"><span class="kw">crs</span>(contour)</a></code></pre></div>
<pre><code>## CRS arguments: NA</code></pre>
<p>Unfortunately <code>rasterToPolygons()</code> does not assign a coordinate reference system, so we have to do so ourselves. While we’re at it, let’s also transform this to the <code>sf</code> format:</p>
<div class="sourceCode" id="cb311"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb311-1" title="1"><span class="kw">crs</span>(contour)&lt;-<span class="kw">crs</span>(chm)</a>
<a class="sourceLine" id="cb311-2" title="2">contour&lt;-<span class="kw">st_as_sf</span>(contour)<span class="op">%&gt;%</span><span class="kw">rename</span>(<span class="dt">treeID =</span> layer)</a></code></pre></div>
<p>Next we can save the delineated polygons:</p>
<div class="sourceCode" id="cb312"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb312-1" title="1"><span class="kw">st_write</span>(contour, <span class="st">&#39;outputs/contour_sf.shp&#39;</span>)</a></code></pre></div>
<p>Again we want to test our knowledge and apply what we’ve just learned to the other example file.</p>
</div>
<div id="challenge-2-6" class="section level3">
<h3><span class="header-section-number">9.5.2</span> Challenge 2</h3>
<p><strong>Detect trees and treetops in our other example file based on the derived CHM and normalized pointcloud and plot smoothed CHM, hulls and detected treetops on top of one another</strong></p>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-45-1.png" width="672" /></p>
</div>
</div>
<div id="additional-analysis-computing-a-digital-terrain-model-dtm" class="section level2">
<h2><span class="header-section-number">9.6</span> Additional analysis: Computing a digital terrain model (DTM)</h2>
<p>For many applications and studies, it is important to have detailed topographic data to e.g. assess slope, aspect or potential for water runoff in the ecosystem you’re studying. As LiDAR data penetrates through the canopy and captures laser returns from the ground as well, we can use the data not only to look at above ground structure, but also derive very high resolution digital terrain models (DTMs) that may be helpful in our analysis. Do to so, we are using the classified pointcloud that has ground points detected (which we named <code>raw_forest_ground</code>). <code>grid_terrain()</code> interpolates the ground points and creates a rasterized digital terrain model. The algorithm uses the points classified as “ground” to compute the interpolation.</p>
<div class="sourceCode" id="cb313"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb313-1" title="1">dtm &lt;-<span class="st"> </span><span class="kw">grid_terrain</span>(raw_forest_ground, <span class="dv">1</span>, <span class="dt">algorithm =</span> <span class="kw">kriging</span>(<span class="dt">k =</span> 10L))</a></code></pre></div>
<pre><code>## Registered S3 method overwritten by &#39;xts&#39;:
##   method     from
##   as.zoo.xts zoo</code></pre>
<div class="sourceCode" id="cb315"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb315-1" title="1"><span class="kw">plot</span>(dtm)</a></code></pre></div>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-46-1.png" width="672" /></p>
<div class="sourceCode" id="cb316"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb316-1" title="1"><span class="kw">summary</span>(dtm)</a></code></pre></div>
<pre><code>##                Z
## Min.    312.7800
## 1st Qu. 324.2830
## Median  329.7095
## 3rd Qu. 334.8963
## Max.    347.8690
## NA&#39;s      8.0000</code></pre>
<p>What you can see when plotting is the topography of the ground under the trees in a unit of meters above sea level (which is derived from the coordinates of each point). We can see that our elevation varies between 313 to 348. The second argument of the function is again the resolution, which we set to <code>1</code> (1x1 m). This is an amazingly high resolution, when you think that the next best (free) DTM available from the <a href="https://www2.jpl.nasa.gov/srtm/">Shuttle Radar Topography Mission</a> is 30x30 meters. Very high resolution DTMs can be used for detailed analyses of stream flow in hydrological applications, geomorphology or modeling soil wetness with Cartographic Depth to Water Indexes (DTW-index). We are using another algorithm here (<code>kriging</code>) that applies a KNN (k-nearest neighbor) approach, commonly used in DTM creation. We can plot our crowns on top to see where the trees are distributed and how topography might be influencing e.g. the height or crown shape of trees here:</p>
<div class="sourceCode" id="cb318"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb318-1" title="1"><span class="kw">plot</span>(dtm)</a>
<a class="sourceLine" id="cb318-2" title="2"><span class="kw">plot</span>(contour<span class="op">$</span>geometry, <span class="dt">add =</span> T)</a></code></pre></div>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-47-1.png" width="672" /></p>
<p>We can save our <code>dtm</code> the same way we saved our CHM before, using <code>writeRaster()</code>. <code>lidR</code> has some integrated LiDAR pointclouds to play around with, that might help illustrate this a bit better. Let’s look at one that has more depressions in the form of lakes, using a different algorithm as illustration:</p>
<div class="sourceCode" id="cb319"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb319-1" title="1">LASfile &lt;-<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="st">&quot;Topography.laz&quot;</span>, <span class="dt">package=</span><span class="st">&quot;lidR&quot;</span>)</a>
<a class="sourceLine" id="cb319-2" title="2">las &lt;-<span class="st"> </span><span class="kw">readLAS</span>(LASfile)</a>
<a class="sourceLine" id="cb319-3" title="3"></a>
<a class="sourceLine" id="cb319-4" title="4">dtm1 &lt;-<span class="st"> </span><span class="kw">grid_terrain</span>(las, <span class="dt">algorithm =</span> <span class="kw">knnidw</span>(<span class="dt">k =</span> 6L, <span class="dt">p =</span> <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb319-5" title="5"></a>
<a class="sourceLine" id="cb319-6" title="6"><span class="kw">plot</span>(dtm1)</a></code></pre></div>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-48-1.png" width="672" /></p>
<p><code>lidR</code> also allows to plot DTMs in 3D:</p>
<div class="sourceCode" id="cb320"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb320-1" title="1"><span class="kw">plot_dtm3d</span>(dtm1)</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-50"></span>
<img src="data/lidR-doc/dtm.png" alt="The example data dtm in 3D" width="800" />
<p class="caption">
Figure 9.6: The example data dtm in 3D
</p>
</div>
<p>Another integrated dataset can be called liked this. Feel free to use these to practice creating CHMs, segmenting trees, extracting tree metrics and calculating a DTM.</p>
<div class="sourceCode" id="cb321"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb321-1" title="1">LASfile2 &lt;-<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;extdata&quot;</span>, <span class="st">&quot;Megaplot.laz&quot;</span>, <span class="dt">package=</span><span class="st">&quot;lidR&quot;</span>)</a>
<a class="sourceLine" id="cb321-2" title="2">las2 &lt;-<span class="st"> </span><span class="kw">readLAS</span>(LASfile)</a></code></pre></div>
<p>Let’s try this on the other example too!</p>
<div id="challenge-3-4" class="section level3">
<h3><span class="header-section-number">9.6.1</span> Challenge 3</h3>
<p><strong>Create a digital terrain model for the other example (<code>forest</code>) and plot the detected treetops on top of the final DTM. Finally, save your DTM as a .tif file to your outputs folder!</strong></p>
<p><img src="07-Lidar_in_R_files/figure-html/unnamed-chunk-54-1.png" width="672" /></p>
</div>
</div>
<div id="wrapping-up" class="section level2">
<h2><span class="header-section-number">9.7</span> Wrapping up</h2>
<p>Good job everyone. You have learned how to get your LiDAR data into R and prepare it for further analysis by detecting ground points and normalizing the clouds. Doing that, we were able to derive a canopy height model and learned about how to improve it’s accuracy. Having derived that, we were able to extract metrics for each tree and delineate our crowns to look at single-tree attributes within our example forest. You were also able to compile your inventory data as a comprehensive table and save everything for further processing. Additionally we derived a very detailed digital terrain model. What follows now can be manifold, Maybe you are interested in the exact location and elevation above sea level of all your trees detected. <code>raster</code> allows you to easily extract data from a raster using a spatial vector such as a shape file by simply using <code>extract</code>:</p>
<div class="sourceCode" id="cb322"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb322-1" title="1">elevation&lt;-<span class="kw">extract</span>(dtm, treetops, <span class="dt">cellnumbers =</span> T, <span class="dt">df=</span>T)<span class="op">%&gt;%</span><span class="kw">rename</span>(<span class="dt">treeID =</span> ID, <span class="dt">elevation =</span> Z)</a>
<a class="sourceLine" id="cb322-2" title="2"></a>
<a class="sourceLine" id="cb322-3" title="3">elevation&lt;-<span class="kw">cbind</span>(elevation,<span class="kw">coordinates</span>(dtm)[elevation[,<span class="dv">2</span>],])</a>
<a class="sourceLine" id="cb322-4" title="4"></a>
<a class="sourceLine" id="cb322-5" title="5">elevation&lt;-elevation<span class="op">%&gt;%</span><span class="kw">select</span>(<span class="op">-</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb322-6" title="6"></a>
<a class="sourceLine" id="cb322-7" title="7"><span class="kw">head</span>(elevation)</a></code></pre></div>
<pre><code>##   treeID elevation        x       y
## 1      1   335.211 488042.5 5189193
## 2      2   335.021 488046.5 5189195
## 3      3   335.255 488042.5 5189203
## 4      4   334.875 488040.5 5189208
## 5      5   334.401 488043.5 5189210
## 6      6   333.578 488044.5 5189222</code></pre>
<p>You could think of other uses, e.g. if you have raster layers describing climatic variables of your forest, you could get precise data for each of your trees and see how it might have affected their growth. You can also use the delineated crowns to extract all pixel data from e.g. multispectral imagery of the crown area of your trees to try and model forest nutrition to make assumptions on the quality of the forest for certain arboreal species.</p>
<p>If you have any questions or comments on this tutorial, feel free to write me an email and I’m happy to try and help out. I have a few other (more basic) tutorials compiled like this one if you are interested.</p>
<p><strong>Good luck with any future LiDAR adventures in <code>R</code>!</strong></p>
</div>
<div id="solutions-to-the-challenges" class="section level2">
<h2><span class="header-section-number">9.8</span> Solutions to the challenges</h2>
<div id="challenge-1-7" class="section level3">
<h3><span class="header-section-number">9.8.1</span> Challenge 1</h3>
<div class="sourceCode" id="cb324"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb324-1" title="1">forest_norm &lt;-<span class="st"> </span><span class="kw">lasnormalize</span>(forest, <span class="kw">tin</span>())</a>
<a class="sourceLine" id="cb324-2" title="2"></a>
<a class="sourceLine" id="cb324-3" title="3">forest_chm &lt;-<span class="st"> </span><span class="kw">grid_canopy</span>(forest_norm, <span class="fl">0.25</span>, <span class="kw">pitfree</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">10</span>,<span class="dv">15</span>), <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="dt">subcircle =</span> <span class="fl">0.2</span>))</a></code></pre></div>
</div>
<div id="challenge-2-7" class="section level3">
<h3><span class="header-section-number">9.8.2</span> Challenge 2</h3>
<div class="sourceCode" id="cb325"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb325-1" title="1"><span class="co">#data to use:</span></a>
<a class="sourceLine" id="cb325-2" title="2"></a>
<a class="sourceLine" id="cb325-3" title="3"><span class="co">#forest_chm</span></a>
<a class="sourceLine" id="cb325-4" title="4"><span class="co">#forest_norm</span></a>
<a class="sourceLine" id="cb325-5" title="5"></a>
<a class="sourceLine" id="cb325-6" title="6"><span class="co"># segment the trees</span></a>
<a class="sourceLine" id="cb325-7" title="7"></a>
<a class="sourceLine" id="cb325-8" title="8">algo &lt;-<span class="st"> </span>lidR<span class="op">::</span><span class="kw">watershed</span>(forest_chm, <span class="dt">th =</span> <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb325-9" title="9">las2  &lt;-<span class="st"> </span><span class="kw">lastrees</span>(forest_norm, algo)</a>
<a class="sourceLine" id="cb325-10" title="10"></a>
<a class="sourceLine" id="cb325-11" title="11">trees_forest &lt;-<span class="st"> </span><span class="kw">lasfilter</span>(las2, <span class="op">!</span><span class="kw">is.na</span>(treeID))</a>
<a class="sourceLine" id="cb325-12" title="12"></a>
<a class="sourceLine" id="cb325-13" title="13"><span class="kw">plot</span>(trees_forest, <span class="dt">color =</span> <span class="st">&quot;treeID&quot;</span>, <span class="dt">colorPalette =</span> <span class="kw">pastel.colors</span>(<span class="dv">100</span>))</a>
<a class="sourceLine" id="cb325-14" title="14"></a>
<a class="sourceLine" id="cb325-15" title="15"><span class="co"># find treetops and hulls</span></a>
<a class="sourceLine" id="cb325-16" title="16"></a>
<a class="sourceLine" id="cb325-17" title="17">treetops_forest&lt;-<span class="kw">tree_detection</span>(forest_norm, <span class="kw">lmf</span>(<span class="dt">ws =</span> <span class="dv">5</span>, <span class="dt">hmin =</span> <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb325-18" title="18"></a>
<a class="sourceLine" id="cb325-19" title="19">metric_forest &lt;-<span class="st"> </span><span class="kw">tree_metrics</span>(trees_forest, .stdtreemetrics)</a>
<a class="sourceLine" id="cb325-20" title="20">hulls_forest  &lt;-<span class="st"> </span><span class="kw">tree_hulls</span>(trees_forest)</a>
<a class="sourceLine" id="cb325-21" title="21">hulls_forest<span class="op">@</span>data &lt;-<span class="st"> </span>dplyr<span class="op">::</span><span class="kw">left_join</span>(hulls<span class="op">@</span>data, metric<span class="op">@</span>data)</a>
<a class="sourceLine" id="cb325-22" title="22"></a>
<a class="sourceLine" id="cb325-23" title="23"><span class="kw">plot</span>(forest_chm)</a>
<a class="sourceLine" id="cb325-24" title="24"><span class="kw">plot</span>(hulls_forest, <span class="dt">add =</span> T)</a>
<a class="sourceLine" id="cb325-25" title="25"><span class="kw">plot</span>(treetops_forest, <span class="dt">add =</span> T) </a></code></pre></div>
</div>
<div id="challenge-3-5" class="section level3">
<h3><span class="header-section-number">9.8.3</span> Challenge 3</h3>
<div class="sourceCode" id="cb326"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb326-1" title="1">dtm2 &lt;-<span class="st"> </span><span class="kw">grid_terrain</span>(forest, <span class="dv">1</span>, <span class="dt">algorithm =</span> <span class="kw">kriging</span>(<span class="dt">k =</span> 10L))</a>
<a class="sourceLine" id="cb326-2" title="2"></a>
<a class="sourceLine" id="cb326-3" title="3"><span class="kw">writeRaster</span>(dtm2, <span class="st">&#39;outputs/forest_DTM.tif&#39;</span>)</a>
<a class="sourceLine" id="cb326-4" title="4"></a>
<a class="sourceLine" id="cb326-5" title="5"><span class="kw">plot</span>(dtm2)</a>
<a class="sourceLine" id="cb326-6" title="6"><span class="kw">plot</span>(treetops_forest, <span class="dt">add =</span> T)</a></code></pre></div>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="working-with-spatial-data-in-r.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="extracting-raster-fractions-and-area-using-a-polygon-mask.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
